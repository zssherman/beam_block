#!/usr/bin/env python

"""
To use bb_from_radar.py as a command
If anaconda3 is install:
     Move bb_from_radar.py to /home/user/anconda3/bin/
If not:
    vim ~/.bashrc
    Add `export PATH=/filelocation:$PATH`

Remove.py from end of filename
In bash type `chmod -x /home/user/anaconda3/bin/bb_from_radar`

"""
# Note docstring below is as if beam_block will be added
# to Py-ART in the future.

"""
pyart.retrieve.beam_block_calc
=======================================

Calculates partial beam block(PBB) and cumulative beam block(CBB)
by using wradlib's beamblock and geotiff functions. PBB and CBB
are then used to created flags when a certain beam block fraction
is passed. Empty radar object is created using Py-ART and then
is filled with beam block data.

.. autosummary::
    :toctreeL generated/
    :template: dev_template.rst

    beam_block
    empty_radar_beam_block_ppi
    beam_block_flag
    _arrays_to_dict
    _flags_to_dict

"""

import argparse
import pyart
# import warnings
import numpy as np
import wradlib as wrl

# warnings.filterwarnings("ignore", category=RuntimeWarning)


def beam_block(radar, tif_file,
               beam_width=1.0):
    """
    Beam Block Calculation

    Parameters
    ----------
    radar : Radar
        Radar object used.
    tif_name : string
        Name of geotiff file to use for the
        calculation

    Other Parameters
    ----------------
    beam_width : float
        Radar's beam width for calculation.
        Default value is 1.0.

    Returns
    -------
    pbb : array
        Array of partial beam block fractions for each
        gate in each ray.
    cbb: array
        Array of cumulative beam block fractions for
        each gate in each ray.

    References
    ----------
    Bech, J., B. Codina, J. Lorente, and D. Bebbington,
    2003: The sensitivity of single polarization weather
    radar beam blockage correction to variability in the
    vertical refractivity gradient. J. Atmos. Oceanic
    Technol., 20, 845–855

    Heistermann, M., Jacobi, S., and Pfaff, T., 2013:
    Technical Note: An open source library for processing
    weather radar data (wradlib), Hydrol. Earth Syst.
    Sci., 17, 863-871, doi:10.5194/hess-17-863-2013

    Helmus, J.J. & Collis, S.M., (2016). The Python ARM
    Radar Toolkit (Py-ART), a Library for Working with
    Weather Radar Data in the Python Programming Language.
    Journal of Open Research Software. 4(1), p.e25.
    DOI: http://doi.org/10.5334/jors.119

    """

    # Emptying the radar fields.
    radar.fields.clear()
    _range = radar.range['data']
    beamradius = wrl.util.half_power_radius(_range, beam_width)

    # Opening the tif file and getting the values ready to be
    # converted into polar values.
    rasterfile = tif_file
    data_raster = wrl.io.open_raster(rasterfile)
    proj_raster = wrl.georef.wkt_to_osr(data_raster.GetProjection())
    rastercoords, rastervalues = wrl.io.read_raster_data(rasterfile)
    sitecoords = (np.float(radar.longitude['data']),
                  np.float(radar.latitude['data']),
                  np.float(radar.altitude['data']))

    pbb_arrays = []
    cbb_arrays = []
    # Cycling through all sweeps in the radar object.
    for i in range(len(radar.sweep_start_ray_index['data'])):
        index_start = radar.sweep_start_ray_index['data'][i]
        index_end = radar.sweep_end_ray_index['data'][i]

        nrays = index_end - index_start + 1
        nbins = radar.ngates
        range_res = (np.max(_range) - np.min(_range)) / (nbins - 1)

        # Determine if the scan is a ppi or rhi scan.
        if radar.scan_type is 'ppi':
            elev = radar.fixed_angle['data'][i]
            coord = wrl.georef.sweep_centroids(nrays, range_res,
                                               nbins, elev)
            lon, lat, alt = wrl.georef.polar2lonlatalt_n(
                coord[..., 0], np.degrees(coord[..., 1]),
                coord[..., 2], sitecoords)

        if radar.scan_type is 'rhi':
            lon = radar.gate_longitude['data'][index_start:index_end +1]
            lat = radar.gate_latitude['data'][index_start:index_end +1]
            alt = radar.gate_altitude['data'][index_start:index_end +1]

        x_pol, y_pol = wrl.georef.reproject(
            lon, lat, projection_target=proj_raster)
        polcoords = np.dstack((x_pol, y_pol))

        rlimits = (x_pol.min(), y_pol.min(), x_pol.max(), y_pol.max())
        # Clip the region inside our bounding box
        ind = wrl.util.find_bbox_indices(rastercoords, rlimits)
        rastercoords = rastercoords[ind[1]:ind[3], ind[0]:ind[2], ...]
        rastervalues = rastervalues[ind[1]:ind[3], ind[0]:ind[2]]

        # Map rastervalues to polar grid points
        polarvalues = wrl.ipol.cart2irregular_spline(
            rastercoords, rastervalues, polcoords)

        pbb = wrl.qual.beam_block_frac(polarvalues, alt, beamradius)
        pbb = np.ma.masked_invalid(pbb)
        pbb_arrays.append(pbb)

        maxindex = np.nanargmax(pbb, axis=1)
        cbb = np.copy(pbb)
        # Iterate over all beams
        for ii, index in enumerate(maxindex):
            premax = 0.
            for jj in range(index):
                # Only iterate to max index to make this faster
                if pbb[ii, jj] > premax:
                    cbb[ii, jj] = pbb[ii, jj]
                    premax = cbb[ii, jj]
                else:
                    cbb[ii, jj] = premax
            # beyond max index, everything is max anyway
            cbb[ii, index:] = pbb[ii, index]
        cbb_arrays.append(cbb)

    pbb_all = np.ma.concatenate(pbb_arrays)
    cbb_all = np.ma.concatenate(cbb_arrays)
    return pbb_all, cbb_all

def beam_block_flag(pbb_all, cbb_all, pbb_threshold,
                    cbb_threshold):
    """ Takes PBB and CBB arrays created from the
    beam_block function and user chosen thresholds
    to create and array of 1s and 0s, 1 is a flagged gate
    where the fraction value is past the threshold. """
    pbb_flags = np.empty_like(pbb_all)
    pbb_flags[pbb_all > pbb_threshold] = 1
    pbb_flags[pbb_all < pbb_threshold] = 0

    cbb_flags = np.empty_like(cbb_all)
    cbb_flags[cbb_all > cbb_threshold] = 1
    cbb_flags[cbb_all < cbb_threshold] = 0
    return pbb_flags, cbb_flags

def _arrays_to_dict(pbb_all, cbb_all):
    """ Function that takes the PBB and CBB arrays
    and turns them into dictionaries to be used and added
    to the pyart radar object. """
    pbb_dict = {}
    pbb_dict['coordinates'] = 'elevation, azimuth, range'
    pbb_dict['units'] = 'unitless'
    pbb_dict['data'] = pbb_all
    pbb_dict['standard_name'] = 'partial_beam_block'
    pbb_dict['long_name'] = 'Partial Beam Block Fraction'
    pbb_dict['comment'] = 'Partial beam block fraction due to terrain'

    cbb_dict = {}
    cbb_dict['coordinates'] = 'elevation, azimuth, range'
    cbb_dict['units'] = 'unitless'
    cbb_dict['data'] = cbb_all
    cbb_dict['standard_name'] = 'cumulative_beam_block'
    cbb_dict['long_name'] = 'Cumulative Beam Block Fraction'
    cbb_dict['comment'] = 'Cumulative beam block fraction due to terrain'
    return pbb_dict, cbb_dict

def _flags_to_dict(pbb_flags, cbb_flags):
    """ Function that takes the PBB_flag and CBB_flag
    arrays and turns them into dictionaries to be used
    and added to the pyart radar object. """
    pbb_flag_dict = {}
    pbb_flag_dict['units'] = 'unitless'
    pbb_flag_dict['data'] = pbb_flags
    pbb_flag_dict['standard_name'] = 'partial_beam_block_flag'
    pbb_flag_dict['long_name'] = 'Partial Beam Block Flag'
    pbb_flag_dict['comment'] = 'Partial beam block fraction flag, ' \
                            '1 for flagged values, 0 for non-flagged.'

    cbb_flag_dict = {}
    cbb_flag_dict['units'] = 'unitless'
    cbb_flag_dict['data'] = cbb_flags
    cbb_flag_dict['standard_name'] = 'cumulative_beam_block_flag'
    cbb_flag_dict['long_name'] = 'Cumulative Beam Block Flag'
    cbb_flag_dict['comment'] = 'Cumulative beam block fraction flag, ' \
                            '1 for flagged values, 0 for non-flagged.'
    return pbb_flag_dict, cbb_flag_dict

def beam_block_file(args):
    print('')
    print('## Creating a radar object with beam block fields')
    print('')
    radar_file = args.radar_file
    tif_file = args.tif_file
    out_file = args.out_file
    radar = pyart.io.read(radar_file)
    tif = tif_file

    # Running block and flag functions to obtain pbb, cbb and flags.
    pbb_all, cbb_all = beam_block(
        radar, tif, 1.0)
    pbb_flags, cbb_flags = beam_block_flag(
        pbb_all, cbb_all, 0.2, 0.2)

    # Take pbb and cbb arrays and flags for both and creating dictionaries.
    pbb_dict, cbb_dict = _arrays_to_dict(
        pbb_all, cbb_all)
    pbb_flag_dict, cbb_flag_dict = _flags_to_dict(
        pbb_flags, cbb_flags)

    # Add all fields to radar object.
    radar.add_field('partial_beam_block',
                    pbb_dict, replace_existing=True)
    radar.add_field('cumulative_beam_block',
                    cbb_dict, replace_existing=True)
    radar.add_field('partial_beam_block_flag',
                    pbb_flag_dict, replace_existing=True)
    radar.add_field('cumulative_beam_block_flag',
                    cbb_flag_dict, replace_existing=True)
    pyart.io.write_cfradial(out_file, radar)
    return

# Creating func and argument parser for terminal use of this file.
parser = argparse.ArgumentParser(
    description='Create a radar object with beam block fields.')
subparsers = parser.add_subparsers()
beam_block_parser = subparsers.add_parser('beam_block_file')
beam_block_parser.add_argument(
    'radar_file', type=str, help='Radar file to use for calculations.')
beam_block_parser.add_argument(
    'tif_file', type=str, help='Tif file to use as terrain data.')
beam_block_parser.add_argument(
    'out_file', type=str, help='Out file path and name to use.')
beam_block_parser.set_defaults(func=beam_block_file)
args = beam_block_parser.parse_args()
args.func(args)
